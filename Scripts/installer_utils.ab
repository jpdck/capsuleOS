import { echo_colored, env_var_get, env_var_set } from "std/env"
import { lpad, rpad, trim, text_contains } from "std/text"
import { file_exists } from "std/fs"

const USER = trust env_var_get("USER")

pub fun title_header(): Null {
    let border = "═══════════════════════════════════════════"
    let width = len(border) + 2
    
    echo ""
    echo "╔{border}╗"
    let header = "capsuleOS AMBER INSTALL SYSTEM"
    let header_padding = (width - len(header)) / 2
    let header_line = rpad(lpad(header, " ", header_padding + len(header)), " ", width-2)
    echo "║{header_line}║"
    echo "╚{border}╝"
    echo ""
}

pub fun title_footer(): Null {
    let border = "═══════════════════════════════════════════"
    let width = len(border) + 2
    
    echo ""
    echo "╔{border}╗"
    let header = "capsuleOS AMBER INSTALL SYSTEM"
    let header_padding = (width - len(header)) / 2
    let header_line = rpad(lpad(header, " ", header_padding + len(header)), " ", width-2)
    echo "║{header_line}║"

    let footer = "INSTALLATION COMPLETE"
    let footer_padding = (width - len(footer)) / 2
    let footer_line = rpad(lpad(footer, " ", footer_padding + len(footer)), " ", width-6)
    echo "║> {footer_line} <║"
    echo "╚{border}╝"
    echo ""
}

pub fun stage_header(stage_name: Text, ref stage: Int): Null {
    stage = stage + 1
    silent trust $sleep 1$
    echo ""
    echo_colored("═══ STAGE {stage}: {stage_name} ═══", 36)
    echo ""
}

pub fun info(message: Text): Null {
    echo_colored("  {message}", 37)
}

pub fun warning(message: Text): Null {
    echo_colored("  [WARNING] {message}", 33)
}

pub fun error(message: Text): Null {
    echo_colored("  [ERROR] {message}", 31)
}

pub fun store_keychain(service: Text, value: Text): Null {
    // Remove existing entry (ignore failure - likely doesn't exist)
    silent trust $ security delete-generic-password -a "{USER}" -s "{service}" $

    // Add new entry
    $ security add-generic-password -a "{USER}" -s "{service}" -w "{value}" -U $ failed(code) {
        warning("Failed to store {service} in Keychain")
    }
}

pub fun is_empty(text: Text): Bool {
    return len(trim(text)) == 0
}

pub fun configure_brew_path(): Null {
    if {
        file_exists("/opt/homebrew/bin/brew"): {
            silent trust $ eval "\$(/opt/homebrew/bin/brew shellenv)" $
        }
        file_exists("/usr/local/bin/brew"): {
            silent trust $ eval "\$(/usr/local/bin/brew shellenv)" $
        }
    }
}

pub fun configure_cargo_path(): Null {
    const HOME = trust env_var_get("HOME")
    if file_exists("{HOME}/.cargo/bin/cargo") {
        let current_path = trust env_var_get("PATH")
        env_var_set("PATH", "{HOME}/.cargo/bin:{current_path}") failed {
            warning("Failed to add cargo to PATH")
        }
    }
}

pub fun is_interactive(): Bool {
    // Check if stdin is a terminal (file descriptor 0)
    silent $ test -t 0 $ failed {
        return false
    }
    return true
}

pub fun configure_mas_sudo(): Null {
    // Dynamically determine mas path
    let mas_path = trust $ command -v mas $

    if not is_empty(mas_path) {
        const SUDOERS_FILE = "/etc/sudoers.d/mas-upgrade"
        let sudoers_content = "{USER} ALL=(root) NOPASSWD: {mas_path} upgrade\n"

        info("Configuring passwordless sudo for mas upgrade")

        // Write sudoers file with proper permissions
        $ echo '{sudoers_content}' | sudo tee {SUDOERS_FILE} > /dev/null $ failed(code) {
            error("Failed to create sudoers file")
            exit code
        }

        // Set correct permissions (440)
        $ sudo chmod 440 {SUDOERS_FILE} $ failed(code) {
            error("Failed to set sudoers file permissions")
            exit code
        }

        // Validate sudoers configuration
        $ sudo visudo -c $ failed(code) {
            error("Sudoers configuration is invalid")
            exit code
        }

        // Verify the rule is in effect
        let verify = $ sudo -l -U {USER} $ failed {
            warning("Could not verify sudo configuration")
        }

        if not is_empty(verify) {
            if not text_contains(verify, "NOPASSWD") or not text_contains(verify, "mas upgrade") {
                warning("Sudo rule may not be active - check with: sudo -l")
            }
        }

        info("Passwordless sudo configured for mas upgrade")
    } else {
        warning("mas command not found - cannot configure passwordless sudo")
    }
}