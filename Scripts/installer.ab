// -----------------------------------------------//
// capsuleOS Installer                            //
// https://github.com/jpdck/capsuleOS             //
// -----------------------------------------------//

import { split, text_contains, split_lines, trim, join, starts_with } from "std/text"
import { is_command, env_var_get, env_var_set, input_prompt, input_confirm, input_hidden, echo_colored } from "std/env"
import { file_exists, file_chmod, file_write, dir_exists, file_read, dir_create } from "std/fs"
import { file_download } from "std/http"
import * from "installer_utils.ab"

const USER = trust env_var_get("USER")
const HOME = trust env_var_get("HOME")
const REPO_DIR = "{HOME}/Projects/capsuleOS"
const TEMP_DIR = trust $ mktemp -d -t capsuleOS-installer $

if TEMP_DIR == "" or not dir_exists(TEMP_DIR) {
    echo_colored("Failed to create temporary directory. Exiting.", 31)
    exit 1
}

let STAGE = 0

fun apply_macos_defaults(): Null? {
    silent {
        // Global Interface Settings
        $ defaults write NSGlobalDomain ApplePressAndHoldEnabled -bool false $?
        $ defaults write NSGlobalDomain AppleShowAllExtensions -bool true $?
        $ defaults write NSGlobalDomain InitialKeyRepeat -int 14 $?
        $ defaults write NSGlobalDomain KeyRepeat -int 1 $?
        $ defaults write NSGlobalDomain AppleInterfaceStyle -string "Dark" $?
        $ defaults write NSGlobalDomain AppleScrollerPagingBehavior -bool true $?
        $ defaults write NSGlobalDomain NSNavPanelExpandedStateForSaveMode -bool true $?
        $ defaults write NSGlobalDomain PMPrintingExpandedStateForPrint -bool true $?
        $ defaults write NSGlobalDomain "com.apple.trackpad.scaling" -float 2.0 $?
        $ defaults write NSGlobalDomain "com.apple.mouse.tapBehavior" -int 1 $?
        $ defaults write NSGlobalDomain AppleKeyboardUIMode -int 3 $?
        $ defaults write NSGlobalDomain com.apple.swipescrolldirection -bool true $?

        // Dock Configuration
        $ defaults write com.apple.dock autohide -bool false $?
        $ defaults write com.apple.dock orientation -string "bottom" $?
        $ defaults write com.apple.dock showhidden -bool true $?
        $ defaults write com.apple.dock mineffect -string "genie" $?
        $ defaults write com.apple.dock show-recents -bool false $?
        $ defaults write com.apple.dock tilesize -int 36 $?
        $ defaults write com.apple.dock magnification -bool true $?
        $ defaults write com.apple.dock largesize -int 48 $?
        $ defaults write com.apple.dock autohide-delay -float 0.0 $?
        $ defaults write com.apple.dock autohide-time-modifier -float 0.5 $?

        // Finder Settings
        $ defaults write com.apple.finder AppleShowAllFiles -bool true $?
        $ defaults write com.apple.finder AppleShowAllExtensions -bool true $?
        $ defaults write com.apple.finder ShowPathbar -bool true $?
        $ defaults write com.apple.finder ShowStatusBar -bool true $?
        $ defaults write com.apple.finder _FXSortFoldersFirst -bool true $?
        $ defaults write com.apple.finder FXPreferredViewStyle -string "Nlsv" $?
        $ defaults write com.apple.finder QuitMenuItem -bool true $?

        // Trackpad Settings
        $ defaults write com.apple.driver.AppleBluetoothMultitouch.trackpad Clicking -bool true $?
        $ defaults write com.apple.AppleMultitouchTrackpad Clicking -bool true $?
    }
}

title_header()

// Stage 1: macOS Dependency Setup
// Ensure the macOS environment is prepared for installation with Xcode CLI tools and Homebrew
stage_header("macOS Dependency Setup", STAGE)
{
    // Verify Xcode Command Line Tools installation
    info("Checking for Xcode CLI tools installation")
    if not is_command("xcode-select") {
        info("Installing Xcode CLI tools")
        $ xcode-select --install $ failed(code) {
            log_message("Xcode CLI tools installation failed with code", code)
            error("Failed to install Xcode CLI tools")
            exit 1
        }
        
        let message = "Xcode CLI tools installed successfully"
        info(message)
        log_message(message)
    } else {
        let message = "Xcode CLI tools are already installed"
        info(message)
        log_message(message)
    }

    // Verify Homebrew installation
    info("Checking for Homebrew installation")

    // First, check if Homebrew binary exists and configure PATH if needed
    let brew_installed = file_exists("/opt/homebrew/bin/brew") or file_exists("/usr/local/bin/brew")

    if brew_installed and not is_command("brew") {
        info("Configuring Homebrew environment")
        if {
            file_exists("/opt/homebrew/bin/brew"): {
                silent trust $ eval "\$(/opt/homebrew/bin/brew shellenv)" $
            }
            file_exists("/usr/local/bin/brew"): {
                silent trust $ eval "\$(/usr/local/bin/brew shellenv)" $
            }
        }
    }

    if not is_command("brew") and not brew_installed {
        info("Installing Homebrew")
        $ NONINTERACTIVE=1 CI=1 /bin/bash -c "\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" $ failed(code) {
            let message = "Failed to install Homebrew"
            log_message(message, code)
            error(message)
            exit 1
        }
        let message = "Homebrew installed successfully"
        info(message)
        log_message(message)

        info("Configuring Homebrew environment")
        if {
            file_exists("/opt/homebrew/bin/brew"): {
                silent trust $ eval "\$(/opt/homebrew/bin/brew shellenv)" $
            }
            file_exists("/usr/local/bin/brew"): {
                silent trust $ eval "\$(/usr/local/bin/brew shellenv)" $
            }
        }
    }

    if is_command("brew") {
        info("Homebrew detected, performing update")
        $ brew update $ failed(code) {
            let message = "Failed to update Homebrew"
            log_message(message, code)
            error(message)
            exit 1
        }
        info("Upgrading existing Homebrew packages")
        $ brew upgrade $ failed(code) {
            let message = "Failed to upgrade Homebrew packages"
            log_message(message, code)
            error(message)
            exit 1
        }
        let message = "Homebrew is up to date"
        info(message)
        log_message(message)
    }
}

// Stage 2: Homebrew Package Installation
// Install necessary packages via Homebrew using a Brewfile
stage_header("Installing Homebrew packages", STAGE)
{
    info("Downloading latest Brewfile from repository")
    let brewfile_path = "{TEMP_DIR}/Brewfile"
    file_download("https://github.com/jpdck/capsuleOS/releases/download/latest/Brewfile", brewfile_path) failed(code) {
        let message = "Failed to download Brewfile"
        log_message(message, code)
        error(message)
        exit 1
    }
    info("Brewfile downloaded successfully")
    log_message("Brewfile downloaded to {brewfile_path}")

    info("Installing Homebrew packages from Brewfile")
    let result = $ brew bundle install --file="{brewfile_path}" $ failed(code) {
        log_message("Failed to install Homebrew packages via Brewfile", code)
        error("Failed to install Homebrew packages via Brewfile")
        exit 1
    }
    let message = "Homebrew packages installed successfully from Brewfile"
    info(message)
    log_message(message)
}

// Stage 3: 1Password Integration Setup
// Configure 1Password CLI and import necessary credentials
stage_header("Setting up 1Password integration", STAGE)
{
    info("Checking for 1Password CLI")
    if not is_command("op") {
        let message = "1Password CLI not found - required for credential management"
        log_message(message)
        error(message)
        exit 1
    }
    info("1Password CLI detected")
    log_message("1Password CLI detected")
    // Prompt for service token
    info("Configuring 1Password service token")
    echo_colored("Please enter your 1Password Service Token:", 33)
    echo_colored("(You can create one at https://my.1password.com/developer-tools/infrastructure-secrets)", 33)
    
    let token = input_hidden("")
    
    if len(trim(token)) == 0 {
        let message = "No service token provided - required for 1Password integration"
        log_message(message)
        error(message)
        exit 1
    }
    
    // Store token in macOS Keychain for persistence across sessions
    // This allows future runs to retrieve the token without re-prompting
    info("Storing service token in macOS Keychain")
    $ security delete-generic-password -a "{USER}" -s "op-service-token" $ failed {
        // Ignore failure - likely means no existing token
        log_message("No existing service token to remove (expected on first run)")
    }
    
    $ security add-generic-password -a "{USER}" -s "op-service-token" -w "{token}" -U $ failed(code) {
        let message = "Failed to store token in Keychain for future use"
        log_message(message, code)
        warning(message)
    }
    info("Service token stored in Keychain")
    log_message("Service token stored securely")
    
    // Set token for current session
    env_var_set("OP_SERVICE_ACCOUNT_TOKEN", token) failed {
        let message = "Failed to set OP_SERVICE_ACCOUNT_TOKEN environment variable"
        log_message(message)
        error(message)
        exit 1
    }


    // Prompt for vault name
    info("Configuring 1Password vault name")

    let vault_name = input_prompt("Enter your 1Password vault name for SSH keys: ")

    if len(trim(vault_name)) == 0 {
        let message = "No vault name provided - required for SSH key import"
        log_message(message)
        error(message)
        exit 1
    }

    // Store in Keychain for future reference
    $ security delete-generic-password -a "{USER}" -s "op-vault-name" $ failed {
        log_message("No existing vault name to remove (expected on first run)")
    }

    $ security add-generic-password -a "{USER}" -s "op-vault-name" -w "{vault_name}" -U $ failed(code) {
        let message = "Failed to store vault name in Keychain for future reference"
        log_message(message, code)
        warning(message)
    }

    info("Vault name configured: {vault_name}")
    log_message("Vault name set to: {vault_name}")


    // Verify vault exists
    info("Verifying {vault_name} vault access")
    let vault_check = $ op vault list --format=json $ failed(code) {
        let message = "Failed to list 1Password vaults"
        log_message(message, code)
        error(message)
        exit 1
    }
    
    if not text_contains(vault_check, vault_name) {
        let message = "{vault_name} vault not found or inaccessible"
        log_message(message)
        error(message)
        exit 1
    }
    info("{vault_name} vault accessible")
    log_message("{vault_name} vault verified")
    // List and import all SSH keys
    info("Fetching SSH keys from {vault_name} vault")
    let ssh_keys_json = $ op item list --vault="{vault_name}" --categories="SSH Key" --format=json $ failed(code) {
        let message = "Failed to list SSH keys from vault"
        log_message(message, code)
        error(message)
        exit 1
    }
    
    // Parse SSH key list
    let ssh_keys_raw = trust $ echo '{ssh_keys_json}' | jq -r '.[] | .title + "|" + .id' $
    
    if len(trim(ssh_keys_raw)) == 0 {
        let message = "No SSH keys found in {vault_name} vault"
        log_message(message)
        error(message)
        exit 1
    }
    
    let key_lines = split_lines(trim(ssh_keys_raw))
    let key_lines_count = 0
    for line in key_lines {
        key_lines_count += 1
    }
    info("Found {key_lines_count} SSH key(s) in vault")
    log_message("Found {key_lines_count} SSH key(s) to import")
    
    // Create .ssh directory
    let ssh_dir = "{HOME}/.ssh"
    if not dir_exists(ssh_dir) {
        dir_create(ssh_dir) failed(code) {
            let message = "Failed to create .ssh directory"
            log_message(message, code)
            error(message)
            exit 1
        }
    }
    silent $ chmod 700 "{ssh_dir}" $ failed(code) {
        let message = "Failed to set permissions on .ssh directory"
        log_message(message, code)
        error(message)
        exit 1
    }
    
    info("Importing all SSH keys")
    
    // Process each key
    for i, key_line in key_lines {
        let parts = split(key_line, "|")
        let parts_length = 0
        for p in parts {
            parts_length += 1
        }
        if parts_length < 2 {
            log_message("Skipping invalid key line format: {key_line}")
            continue
        }
        let key_title = parts[0]
        let key_id = parts[1]
        
        info("Processing SSH key {i + 1}/{key_lines_count}: {key_title}")
        
        // Get key details from 1Password
        let key_json = $ op item get "{key_id}" --vault="{vault_name}" --format=json $ failed(code) {
            let message = "Failed to fetch key details for {key_title}"
            log_message(message, code)
            warning(message)
            continue
        }
        
        // Extract private key
        let private_key = trust $ echo '{key_json}' | jq -r '.fields[] | select(.label=="private key") | .value' $
        
        if len(trim(private_key)) == 0 or private_key == "null" {
            warning("Could not extract private key for {key_title}")
            log_message("Private key extraction failed for {key_title}")
            continue
        }
        
        // Determine filename - vault's primary key gets default name
        let key_filename = ""
        if key_title == vault_name {
            key_filename = "id_ed25519"
        } else {
            // Sanitize key title for filesystem
            let sanitized = trust $ echo "id_{key_title}" | tr ' ' '_' | tr -cd '[:alnum:]_.-' $
            key_filename = trim(sanitized)
        }
        
        // Write private key
        let key_path = "{ssh_dir}/{key_filename}"
        file_write(key_path, private_key) failed(code) {
            let message = "Failed to write private key: {key_filename}"
            log_message(message, code)
            warning(message)
            continue
        }
        file_chmod(key_path, "600") failed(code) {
            let message = "Failed to set permissions on private key: {key_filename}"
            log_message(message, code)
            warning(message)
        }
        
        // Extract and write public key
        let public_key = trust $ echo '{key_json}' | jq -r '.fields[] | select(.label=="public key") | .value' $
        
        if len(trim(public_key)) > 0 and public_key != "null" {
            let pub_path = "{key_path}.pub"
            file_write(pub_path, public_key) failed(code) {
                log_message("Failed to write public key for {key_filename}", code)
                warning("Could not write public key for {key_filename}")
            }
            file_chmod(pub_path, "644") failed(code) {
                log_message("Failed to set permissions on public key for {key_filename}", code)
            }
        }
        
        // Start SSH agent if not running
        silent $ pgrep -x ssh-agent > /dev/null $ failed {
            silent trust $ eval "\$(ssh-agent -s)" $
        }
        
        // Add to SSH agent
        silent $ ssh-add "{key_path}" $ failed {
            warning("Imported {key_filename} but could not add to SSH agent")
            log_message("Failed to add {key_filename} to SSH agent")
        }

        info("Imported and added {key_filename} to SSH agent")
        log_message("SSH key {key_filename} imported successfully")
    }
    
    info("All SSH keys imported ({key_lines_count} total)")
    log_message("SSH key import completed: {key_lines_count} keys processed")
}

// Stage 4: macOS Defaults Configuration
// Apply recommended macOS system settings for optimal performance
stage_header("Configuring macOS settings", STAGE)
{
    if input_confirm("Apply recommended macOS system settings?", true) {
        info("Applying macOS system settings...")

        info("Configuring interface, dock, finder, and trackpad settings")
        apply_macos_defaults() failed(code) {
            log_message("Failed to apply macOS defaults", code)
            error("Failed to apply macOS defaults")
            exit 1
        }
        
        // Restarting services
        info("Restarting affected services")
        silent trust $ killall Dock Finder SystemUIServer $

        info("macOS system settings applied")
        log_message("macOS system settings applied")
    } else {
        warning("Skipping macOS system settings")
        log_message("Skipped macOS system settings")
    }
}

// Stage 5: capsuleOS Repository Setup
// Clone or update the capsuleOS repository for further development
stage_header("Setting up capsuleOS repository", STAGE)
{
    if not dir_exists(REPO_DIR) {
        info("Cloning capsuleOS repository")
        $ git clone git@github.com:jpdck/capsuleOS.git "{REPO_DIR}" $ failed(code) {
            let message = "Failed to clone capsuleOS repository"
            log_message(message, code)
            error(message)
            exit 1
        }
        info("capsuleOS repository cloned successfully")
        log_message("Repository cloned to {REPO_DIR}")
    } else {
        info("Updating capsuleOS repository")
        $ git -C "{REPO_DIR}" pull origin main $ failed(code) {
            let message = "Failed to update capsuleOS repository"
            log_message(message, code)
            error(message)
            exit 1
        }
        info("capsuleOS repository updated successfully")
        log_message("Repository updated at {REPO_DIR}")
    }
}

// Stage 6: Dotfiles Configuration
// Set up user dotfiles for personalized shell environment
stage_header("Configuring user dotfiles", STAGE)
{
    info("Verifying GNU Stow installation")
    if not is_command("stow") {
        log_message("GNU Stow not found for dotfiles configuration")
        error("GNU Stow is not installed; cannot configure dotfiles")
        exit 1
    }
    info("GNU Stow is installed")
    log_message("GNU Stow found")


    info("Applying dotfiles with GNU Stow")
    const DOTFILES_DIR = "{REPO_DIR}/dotfiles"

    // Verify dotfiles directory exists (should exist since we cloned capsuleOS repo in Stage 5)
    if not dir_exists(DOTFILES_DIR) {
        let message = "Dotfiles directory not found in capsuleOS repository"
        log_message(message)
        error(message)
        exit 1
    }

    // Get list of packages (directories) to stow using absolute path
    let packages_raw = trust $ ls -1d "{DOTFILES_DIR}"/*/ | xargs -n1 basename $
    let packages = split_lines(trim(packages_raw))

    info("Found {len(packages)} package(s) to stow")
    log_message("Packages to stow: {join(packages, ", ")}")

    // Stow each package using explicit directory flag
    for pkg in packages {
        info("Stowing {pkg}...")

        // First attempt to stow with explicit directory
        $ stow -d "{DOTFILES_DIR}" -t "{HOME}" "{pkg}" $ failed(code) {
            // If it failed, remove conflicts and try again
            info("Removing conflicts for {pkg}...")

            // Get list of files that would be stowed using absolute path
            let files_to_stow = trust $ find "{DOTFILES_DIR}/{pkg}" -type f -o -type l $
            let file_list = split_lines(trim(files_to_stow))

            // Remove each conflicting file from HOME
            for file_path in file_list {
                // Strip the dotfiles directory prefix
                let relative_path = trust $ echo "{file_path}" | sed "s|{DOTFILES_DIR}/{pkg}/||" $
                let target_file = "{HOME}/{trim(relative_path)}"

                if file_exists(target_file) {
                    silent trust $ rm -f "{target_file}" $
                    log_message("Removed conflicting file: {target_file}")
                }
            }

            // Try stowing again with explicit directory
            $ stow -d "{DOTFILES_DIR}" -t "{HOME}" "{pkg}" $ failed(retry_code) {
                let message = "Failed to stow {pkg} after removing conflicts"
                log_message(message, retry_code)
                error(message)
                exit 1
            }
        }

        info("Successfully stowed {pkg}")
        log_message("Successfully stowed {pkg}")
    }
    
    info("Dotfiles configuration complete")
    log_message("All dotfiles packages processed")
}

// Stage 7: Additional Language-Specific Tools
// Cargofile (cargo), Amber, Conda
stage_header("Installing additional language-specific tools", STAGE)
{
    info("Downloading latest Cargofile from repository")
    let cargofile_path = "{TEMP_DIR}/Cargofile"
        file_download("https://github.com/jpdck/capsuleOS/releases/download/latest/Cargofile", cargofile_path) failed(code) {
        let message = "Failed to download Cargofile"
        log_message(message, code)
        error(message)
        exit 1
    }
    info("Cargofile downloaded successfully")
    log_message("Cargofile downloaded to {cargofile_path}")


    info("Installing Rust tools via Cargo")
    if not is_command("cargo") {
        error("Cargo not found; skipping Rust tools installation")
        exit 1
    }

    // Read tools from Cargofile and install
    let tools_raw = file_read(cargofile_path) failed(code) {
        let message = "Failed to read Cargofile"
        log_message(message, code)
        error(message)
        exit 1
    }
    let tools = split_lines(trim(tools_raw))
    for tool_raw in tools {
        let tool = trim(tool_raw)
        if len(tool) > 0 and not starts_with(tool, "#") {
            info("Installing {tool} via Cargo")
            $ cargo install {tool} $ failed(code) {
                let message = "Failed to install {tool} via Cargo"
                log_message(message, code)
                error(message)
                exit 1
            }
            info("{tool} installed successfully")
            log_message("{tool} installed via Cargo")
        }
    }


    info("Installing Amber framework")
    // Download install.sh to temp directory
    const amber_installer = "{TEMP_DIR}/amber-install.sh"
    const amber_url = "https://github.com/amber-lang/amber/releases/download/0.5.1-alpha/install.sh"
    const amber_sha256 = "6c5455349fe9454aa2913438ee036275f3b0a2ed744b82a22e3496335bc9ac57"
    
    file_download(amber_url, amber_installer) failed(code) {
        let message = "Failed to download Amber installer"
        log_message(message, code)
        error(message)
        exit 1
    }
    
    // Verify SHA256 checksum
    let computed_sha256 = $ shasum -a 256 {amber_installer} | cut -d ' ' -f1 $ failed(code) {
        let message = "Failed to compute SHA256 checksum of Amber installer"
        log_message(message, code)
        error(message)
        exit 1
    }
    
    if trim(computed_sha256) != amber_sha256 {
        let message = "SHA256 verification failed for Amber installer (expected: {amber_sha256}, got: {trim(computed_sha256)})"
        log_message(message, 1)
        error(message)
        exit 1
    }
    
    // Execute installer after verification
    $ bash {amber_installer} $ failed(code) {
        let message = "Failed to install Amber framework"
        log_message(message, code)
        error(message)
        exit 1
    }
    info("Amber framework installed successfully")
    log_message("Amber framework installed")


    info("Installing Python packages via conda")
    if not is_command("conda") {
        log_message("conda not found; skipped Python packages installation")
        error("conda not found; skipping Python packages installation")
        exit 1
    }
    let python_packages = ["pytest", "ipython", "python-lsp-server"]
    
    for pkg in python_packages {
        $ conda install -y "{pkg}" $ failed(code) {
            let message = "Failed to install {pkg}"
            log_message(message, code)
            warning(message)
            continue
        }
        log_message("{pkg} installed via conda")
    }
    
    info("Python packages installation completed")
    log_message("All conda packages processed")
}

// Stage 8: Finalize and Verify Installation
// Ensure all components are correctly installed and configured
stage_header("Finalizing and verifying installation", STAGE)
{
    info("Verifying installation components")
    let essential_commands = ["git", "brew", "op", "stow", "cargo", "conda"]
    for cmd in essential_commands {
        if not is_command(cmd) {
            let message = "Essential command not found: {cmd}"
            log_message(message)
            warning(message)
        } else {
            log_message("Verified command: {cmd}")
        }
    }
    info("Installation verification completed")
    log_message("Installation process finalized and verified")
}

// Cleanup: Remove temporary directory
stage_header("Cleaning up temporary files", STAGE)
{
    info("Removing temporary directory")
    silent trust $ rm -rf "{TEMP_DIR}" $
    info("Temporary files removed")
    log_message("Cleaned up temporary directory: {TEMP_DIR}")
}

title_footer()
