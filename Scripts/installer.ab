// -----------------------------------------------//
// capsuleOS Installer                            //
// https://github.com/jpdck/capsuleOS             //
// -----------------------------------------------//

import { split, text_contains, split_lines, trim, join, starts_with } from "std/text"
import { is_command, env_var_get, env_var_set, input_prompt, input_confirm, input_hidden, echo_colored } from "std/env"
import { file_exists, file_chmod, file_write, dir_exists, file_read, dir_create } from "std/fs"
import { file_download } from "std/http"
import * from "installer_utils.ab"

const USER = trust env_var_get("USER")
const HOME = trust env_var_get("HOME")
const REPO_DIR = "{HOME}/Projects/capsuleOS"
const TEMP_DIR = trust $ mktemp -d -t capsuleOS-installer $

if TEMP_DIR == "" or not dir_exists(TEMP_DIR) {
    echo_colored("Failed to create temporary directory. Exiting.", 31)
    exit 1
}

let STAGE = 0

fun apply_macos_defaults(): Null? {
    silent {
        // Global Interface Settings
        $ defaults write NSGlobalDomain ApplePressAndHoldEnabled -bool false $?
        $ defaults write NSGlobalDomain AppleShowAllExtensions -bool true $?
        $ defaults write NSGlobalDomain InitialKeyRepeat -int 14 $?
        $ defaults write NSGlobalDomain KeyRepeat -int 1 $?
        $ defaults write NSGlobalDomain AppleInterfaceStyle -string "Dark" $?
        $ defaults write NSGlobalDomain AppleScrollerPagingBehavior -bool true $?
        $ defaults write NSGlobalDomain NSNavPanelExpandedStateForSaveMode -bool true $?
        $ defaults write NSGlobalDomain PMPrintingExpandedStateForPrint -bool true $?
        $ defaults write NSGlobalDomain "com.apple.trackpad.scaling" -float 2.0 $?
        $ defaults write NSGlobalDomain "com.apple.mouse.tapBehavior" -int 1 $?
        $ defaults write NSGlobalDomain AppleKeyboardUIMode -int 3 $?
        $ defaults write NSGlobalDomain com.apple.swipescrolldirection -bool true $?

        // Dock Configuration
        $ defaults write com.apple.dock autohide -bool false $?
        $ defaults write com.apple.dock orientation -string "bottom" $?
        $ defaults write com.apple.dock showhidden -bool true $?
        $ defaults write com.apple.dock mineffect -string "genie" $?
        $ defaults write com.apple.dock show-recents -bool false $?
        $ defaults write com.apple.dock tilesize -int 36 $?
        $ defaults write com.apple.dock magnification -bool true $?
        $ defaults write com.apple.dock largesize -int 48 $?
        $ defaults write com.apple.dock autohide-delay -float 0.0 $?
        $ defaults write com.apple.dock autohide-time-modifier -float 0.5 $?

        // Finder Settings
        $ defaults write com.apple.finder AppleShowAllFiles -bool true $?
        $ defaults write com.apple.finder AppleShowAllExtensions -bool true $?
        $ defaults write com.apple.finder ShowPathbar -bool true $?
        $ defaults write com.apple.finder ShowStatusBar -bool true $?
        $ defaults write com.apple.finder _FXSortFoldersFirst -bool true $?
        $ defaults write com.apple.finder FXPreferredViewStyle -string "Nlsv" $?
        $ defaults write com.apple.finder QuitMenuItem -bool true $?

        // Trackpad Settings
        $ defaults write com.apple.driver.AppleBluetoothMultitouch.trackpad Clicking -bool true $?
        $ defaults write com.apple.AppleMultitouchTrackpad Clicking -bool true $?
    }
}

title_header()

// Detect if we're running interactively and cache sudo credentials if needed
let INTERACTIVE = is_interactive()
if INTERACTIVE {
    info("Interactive mode detected - caching sudo credentials")
    echo_colored("  This installer requires administrative privileges.", 33)
    $ sudo -v $ failed(code) {
        error("Failed to obtain sudo privileges")
        exit code
    }
}

// Stage 1: macOS Dependency Setup
// Ensure the macOS environment is prepared for installation with Xcode CLI tools and Homebrew
stage_header("macOS Dependency Setup", STAGE)
{
    // Verify Xcode Command Line Tools installation
    info("Checking for Xcode CLI tools installation")
    if not is_command("xcode-select") {
        info("Installing Xcode CLI tools")
        $ xcode-select --install $ failed(code) {
            error("Failed to install Xcode CLI tools")
            exit code
        }
        info("Xcode CLI tools installed successfully")
    } else {
        info("Xcode CLI tools are already installed")
    }

    // Verify Homebrew installation
    info("Checking for Homebrew installation")
    let brew_installed = file_exists("/opt/homebrew/bin/brew") or file_exists("/usr/local/bin/brew")

    if {
        not brew_installed {
            // Homebrew binary doesn't exist - need to install
            if not INTERACTIVE {
                error("Homebrew is not installed and cannot be installed in non-interactive mode")
                echo_colored("  Install manually or run this script interactively", 33)
                exit 1
            }

            info("Installing Homebrew (this may take a few minutes)")
            $ /bin/bash -c "\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" $ failed(code) {
                error("Failed to install Homebrew")
                exit code
            }
            info("Homebrew installed successfully")

            configure_brew_path()
        }
        not is_command("brew") {
            // Binary exists but not in PATH - just configure
            info("Configuring Homebrew environment")
            configure_brew_path()
        }
    }

    // At this point, brew should be available - update it
    $ brew update && brew upgrade $ failed(code) {
        error("Failed to update/upgrade Homebrew")
        exit code
    }
    info("Homebrew is up to date")
}

// Stage 2: Homebrew Package Installation and Update Configuration
// Install necessary packages via Homebrew using a Brewfile
// Set up nightly cron job to run for updating brew and running mas upgrade
stage_header("Installing Homebrew packages", STAGE)
{
    info("Downloading latest Brewfile from repository")
    let brewfile_path = "{TEMP_DIR}/Brewfile"
    file_download("https://github.com/jpdck/capsuleOS/releases/download/latest/Brewfile", brewfile_path) failed(code) {
        error("Failed to download Brewfile")
        exit code
    }
    info("Brewfile downloaded successfully")

    info("Installing Homebrew packages from Brewfile")
    $ brew bundle install --file="{brewfile_path}" $ failed(code) {
        error("Failed to install Homebrew packages via Brewfile")
        exit code
    }
    info("Homebrew packages installed successfully from Brewfile")

    info("Initializing GPG directory structure")
    silent $ gpg --list-keys $ failed(code) {
        warning("Failed to initialize GPG directory")
    }

    info("Configuring passwordless sudo for automated updates")
    configure_mas_sudo()
}

// Stage 3: 1Password Integration Setup
// Configure 1Password CLI and import necessary credentials
stage_header("Setting up 1Password integration", STAGE)
{
    info("Checking for 1Password CLI")
    if not is_command("op") {
        error("1Password CLI not found - required for credential management")
        exit 1
    }
    info("1Password CLI detected")
    // Prompt for service token
    info("Configuring 1Password service token")
    echo_colored("Please enter your 1Password Service Token:", 33)
    echo_colored("(You can create one at https://my.1password.com/developer-tools/infrastructure-secrets)", 33)
    
    let token = input_hidden("")

    if is_empty(token) {
        error("No service token provided - required for 1Password integration")
        exit 1
    }

    // Store token in macOS Keychain for persistence across sessions
    info("Storing service token in macOS Keychain")
    store_keychain("op-service-token", token)
    info("Service token stored in Keychain")

    // Set token for current session
    env_var_set("OP_SERVICE_ACCOUNT_TOKEN", token) failed {
        error("Failed to set OP_SERVICE_ACCOUNT_TOKEN environment variable")
        exit 1
    }


    // Prompt for vault name
    info("Configuring 1Password vault name")
    let vault_name = input_prompt("Enter your 1Password vault name for SSH keys: ")

    if is_empty(vault_name) {
        error("No vault name provided - required for SSH key import")
        exit 1
    }

    // Store in Keychain for future reference
    store_keychain("op-vault-name", vault_name)
    info("Vault name configured: {vault_name}")


    // List and import all SSH keys from vault
    info("Fetching SSH keys from {vault_name} vault")
    let ssh_keys_json = $ op item list --vault="{vault_name}" --categories="SSH Key" --format=json $ failed(code) {
        error("Failed to list SSH keys from vault")
        exit code
    }

    // Parse SSH key list
    let ssh_keys_raw = trust $ echo '{ssh_keys_json}' | jq -r '.[] | .title + "|" + .id' $

    if is_empty(ssh_keys_raw) {
        error("No SSH keys found in {vault_name} vault")
        exit 1
    }

    let key_lines = split_lines(trim(ssh_keys_raw))
    let key_lines_count = len(key_lines)
    info("Found {key_lines_count} SSH key(s) in vault")
    
    // Create .ssh directory
    let ssh_dir = "{HOME}/.ssh"
    if not dir_exists(ssh_dir) {
        dir_create(ssh_dir) failed(code) {
            error("Failed to create .ssh directory")
            exit code
        }
    }
    silent $ chmod 700 "{ssh_dir}" $ failed(code) {
        error("Failed to set permissions on .ssh directory")
        exit code
    }
    
    info("Importing all SSH keys")
    
    // Process each key
    for i, key_line in key_lines {
        let parts = split(key_line, "|")
        if len(parts) < 2 {
            continue
        }
        let key_title = parts[0]
        let key_id = parts[1]

        info("Processing SSH key {i + 1}/{key_lines_count}: {key_title}")

        // Get key details from 1Password
        let key_json = $ op item get "{key_id}" --vault="{vault_name}" --format=json $ failed(code) {
            warning("Failed to fetch key details for {key_title}")
            continue
        }

        // Extract private key
        let private_key = trust $ echo '{key_json}' | jq -r '.fields[] | select(.label=="private key") | .value' $

        if is_empty(private_key) or private_key == "null" {
            warning("Could not extract private key for {key_title}")
            continue
        }
        
        // Determine filename - vault's primary key gets default name
        let key_filename = key_title == vault_name
            then "id_ed25519"
            else trim(trust $ echo "id_{key_title}" | tr ' ' '_' | tr -cd '[:alnum:]_.-' $)

        // Write private key
        let key_path = "{ssh_dir}/{key_filename}"
        file_write(key_path, private_key) failed(code) {
            warning("Failed to write private key: {key_filename}")
            continue
        }
        file_chmod(key_path, "600") failed(code) {
            warning("Failed to set permissions on private key: {key_filename}")
        }
        
        // Extract and write public key
        let public_key = trust $ echo '{key_json}' | jq -r '.fields[] | select(.label=="public key") | .value' $

        if not is_empty(public_key) and public_key != "null" {
            let pub_path = "{key_path}.pub"
            file_write(pub_path, public_key) failed(code) {
                warning("Could not write public key for {key_filename}")
            }
            file_chmod(pub_path, "644") failed(code) {
                warning("Failed to set permissions on public key for {key_filename}")
            }
        }

        // Start SSH agent if not running
        silent $ pgrep -x ssh-agent > /dev/null $ failed {
            silent trust $ eval "\$(ssh-agent -s)" $
        }

        // Add to SSH agent
        silent $ ssh-add "{key_path}" $ failed(code) {
            warning("Imported {key_filename} but could not add to SSH agent [{code}]")
        }

        info("Imported and added {key_filename} to SSH agent")
    }

    info("All SSH keys imported ({key_lines_count} total)")
}

// Stage 4: macOS Defaults Configuration
// Apply recommended macOS system settings for optimal performance
stage_header("Configuring macOS settings", STAGE)
{
    if input_confirm("Apply recommended macOS system settings?", true) {
        info("Applying macOS system settings...")
        info("Configuring interface, dock, finder, and trackpad settings")
        apply_macos_defaults() failed(code) {
            error("Failed to apply macOS defaults")
            exit code
        }

        info("Restarting affected services")
        silent trust $ killall Dock Finder SystemUIServer $
        info("macOS system settings applied")
    } else {
        warning("Skipping macOS system settings")
    }
}

// Stage 5: capsuleOS Repository Setup
// Clone or update the capsuleOS repository for further development
stage_header("Setting up capsuleOS repository", STAGE)
{
    if not dir_exists(REPO_DIR) {
        info("Cloning capsuleOS repository")
        $ git clone git@github.com:jpdck/capsuleOS.git "{REPO_DIR}" $ failed(code) {
            error("Failed to clone capsuleOS repository")
            exit code
        }
        info("capsuleOS repository cloned successfully")
    } else {
        info("Updating capsuleOS repository")
        $ git -C "{REPO_DIR}" pull origin main $ failed(code) {
            error("Failed to update capsuleOS repository [{code}]")
        }
    }
}

// Stage 6: Dotfiles Configuration
// Set up user dotfiles for personalized shell environment
stage_header("Configuring user dotfiles", STAGE)
{
    info("Verifying GNU Stow installation")
    if not is_command("stow") {
        error("GNU Stow is not installed; cannot configure dotfiles")
        exit 1
    }
    info("GNU Stow is installed")


    info("Applying dotfiles with GNU Stow")
    const DOTFILES_DIR = "{REPO_DIR}/dotfiles"

    // Verify dotfiles directory exists (should exist since we cloned capsuleOS repo in Stage 5)
    if not dir_exists(DOTFILES_DIR) {
        error("Dotfiles directory not found in capsuleOS repository")
        exit 1
    }

    // Get list of packages (directories) to stow using absolute path
    let packages_raw = trust $ ls -1d "{DOTFILES_DIR}"/*/ | xargs -n1 basename $
    let packages = split_lines(trim(packages_raw))
    info("Found {len(packages)} package(s) to stow")

    // Stow each package using explicit directory flag
    for pkg in packages {
        info("Stowing {pkg}...")

        // First attempt to stow with explicit directory
        $ stow -d "{DOTFILES_DIR}" -t "{HOME}" "{pkg}" $ failed(code) {
            // If it failed, remove conflicts and try again
            info("Removing conflicts for {pkg}...")
            silent trust $ find "{DOTFILES_DIR}/{pkg}" \( -type f -o -type l \) -exec sh -c 'rm -f "{HOME}/\$(echo "\$1" | sed "s|{DOTFILES_DIR}/{pkg}/||")"' _ {} \; $

            // Try stowing again with explicit directory
            $ stow -d "{DOTFILES_DIR}" -t "{HOME}" "{pkg}" $ failed(retry_code) {
                error("Failed to stow {pkg} after removing conflicts")
                exit retry_code
            }
        }

        info("Successfully stowed {pkg}")
    }

    info("Dotfiles configuration complete")

    // Generate and load LaunchAgent for automated updates
    info("Setting up automated update schedule")

    let launchagent_dir = "{HOME}/Library/LaunchAgents"
    let plist_filename = "com.{USER}.update-tools.plist"
    let plist_path = "{launchagent_dir}/{plist_filename}"
    let template_path = "{REPO_DIR}/Scripts/update-tools-launchagent.plist.template"

    // Ensure LaunchAgents directory exists
    if not dir_exists(launchagent_dir) {
        dir_create(launchagent_dir) failed(code) {
            warning("Could not create LaunchAgents directory")
        }
    }

    // Read plist template from repo (already cloned in Stage 5)
    if not file_exists(template_path) {
        warning("LaunchAgent template not found - automated updates will NOT be configured")
    } else {
        let template_content = file_read(template_path) failed(code) {
            warning("Could not read LaunchAgent template - automated updates will NOT be configured")
        }

        // Replace \{\{USER\}\} placeholder with actual username
        let plist_content = trust $ echo '{template_content}' | sed 's/\{\{USER\}\}/{USER}/g' $
        // Replace \{\{HOME\}\} placeholder with actual username
        let plist_content = trust $ echo '{template_content}' | sed 's/\{\{HOME\}\}/{HOME}/g' $

        // Write final plist
        file_write(plist_path, plist_content) failed(code) {
            warning("Could not write LaunchAgent plist - automated updates will NOT be configured")
        }

        // Load the LaunchAgent
        $ launchctl load -w "{plist_path}" $ exited(code) {
            if code == 0 {
                info("Automated updates scheduled (daily at 4:00 AM)")
            } else {
                warning("Automated updates configured but NOT active - load manually: launchctl load -w {plist_path}")
            }
        }
    }
}

// Stage 7: Additional Language-Specific Tools
// Cargofile (cargo), Amber, Conda
stage_header("Installing additional language-specific tools", STAGE)
{
    info("Downloading latest Cargofile from repository")
    let cargofile_path = "{TEMP_DIR}/Cargofile"
    file_download("https://github.com/jpdck/capsuleOS/releases/download/latest/Cargofile", cargofile_path) failed(code) {
        error("Failed to download Cargofile")
        exit code
    }
    info("Cargofile downloaded successfully")

    info("Installing Rust tools via Cargo")
    if {
        not is_command("cargo") {
            configure_cargo_path()
        }
        not is_command("cargo") {
            error("Cargo not found; skipping Rust tools installation")
            exit 1
        }
    }
    
    // Read tools from Cargofile and install
    let tools_raw = file_read(cargofile_path) failed(code) {
        error("Failed to read Cargofile")
        exit code
    }
    for tool_raw in split_lines(trim(tools_raw)) {
        let tool_trimmed = trim(tool_raw)
        // Skip empty lines and comment-only lines
        if len(tool_trimmed) == 0 or starts_with(tool_trimmed, "#") {
            continue
        }
        // Strip inline comments (everything after #)
        let tool_parts = split(tool_trimmed, "#")
        let tool = trim(tool_parts[0])

        if len(tool) > 0 {
            info("Installing {tool} via Cargo")
            $ cargo install {tool} $ failed(code) {
                error("Failed to install {tool} via Cargo")
                exit code
            }
            info("{tool} installed successfully")
        }
    }


    info("Installing Amber framework")
    const AMBER_INSTALLER = "{TEMP_DIR}/amber-install.sh"
    const AMBER_URL = "https://github.com/amber-lang/amber/releases/download/0.5.1-alpha/install.sh"

    if not is_command("amber"){
        file_download(AMBER_URL, AMBER_INSTALLER) failed(code) {
            error("Failed to download Amber installer")
            exit code
        }

        $ bash {AMBER_INSTALLER} $ failed(code) {
            error("Failed to install Amber framework")
            exit code
        }
        info("Amber framework installed successfully")
    } else {
        info("Amber already installed...")
    }


    if  is_command("conda") {
    
        info("Installing Python packages via conda")
        // Accept conda Terms of Service before installing packages
        info("Accepting conda Terms of Service")
        silent {
            $ conda tos accept --override-channels --channel https://repo.anaconda.com/pkgs/main $ failed {
                warning("Failed to accept conda TOS for pkgs/main (may already be accepted)")
            }
            $ conda tos accept --override-channels --channel https://repo.anaconda.com/pkgs/r $ failed {
                warning("Failed to accept conda TOS for pkgs/r (may already be accepted)")
            }
        }

        let python_packages = ["pytest", "ipython", "python-lsp-server"]

        for pkg in python_packages {
            $ conda install -y "{pkg}" $ failed(code) {
                warning("Failed to install {pkg}")
                continue
            }
        }

        info("Python packages installation completed")
    }
}

// Stage 8: Finalize and Verify Installation
// Ensure all components are correctly installed and configured
stage_header("Finalizing and verifying installation", STAGE)
{
    info("Verifying installation components")
    let essential_commands = ["git", "brew", "op", "stow", "cargo", "conda"]
    for cmd in essential_commands {
        if not is_command(cmd) {
            warning("Essential command not found: {cmd}")
        }
    }
    info("Installation verification completed")
}

// Cleanup: Remove temporary directory
stage_header("Cleaning up temporary files", STAGE)
{
    info("Removing temporary directory")
    silent trust $ rm -rf "{TEMP_DIR}" $
    info("Temporary files removed")
}

title_footer()
